"""Tests for generate_thermo_data.py.

These tests verify that the new generator produces output consistent with
the reference header (generated by the legacy scripts from JetSurf2.yaml).
"""

from __future__ import annotations

import re
import tempfile
from pathlib import Path

import pytest
from generate_thermo_data import (  # Species used in the reference header (from JetSurf2)
    NASAFormat,
    SpeciesData,
    _parse_common_names_header,
    _parse_formula_to_name,
    _parse_name_to_formula,
    check_common_names,
    generate_cpp_header,
    list_species_in_yaml,
    load_cantera_yaml,
)

REFERENCE_SPECIES = [
    "N2",
    "O2",
    "AR",
    "CO2",
    "H2O",
    "CH4",
    "C2H6",
    "C3H8",
    "IC4H10",
    "NC5H12",
    "NC6H14",
    "NC7H16",
    "CO",
    "H2",
]

MECHANISM_FILE = Path(__file__).parent / "JetSurf2.yaml"
REFERENCE_HEADER = Path(__file__).parent / "reference_thermo_transport_data.h"


class TestListSpecies:
    """Test species listing functionality."""

    def test_list_species_jetsurf2(self) -> None:
        """Verify we can list species from JetSurf2."""
        species = list_species_in_yaml(MECHANISM_FILE)
        assert len(species) > 100  # JetSurf2 has many species

        # Check our reference species are present
        for sp in REFERENCE_SPECIES:
            assert sp in species, f"Expected species {sp} not found"

    def test_handles_yaml_boolean_parsing(self) -> None:
        """YAML parses 'NO' as False - verify we handle this."""
        # This is tested implicitly by list_species returning strings
        species = list_species_in_yaml(MECHANISM_FILE)
        for sp in species:
            assert isinstance(sp, str), f"Species {sp!r} is not a string"


class TestLoadCanteraYaml:
    """Test YAML mechanism loading."""

    def test_load_filtered_species(self) -> None:
        """Load only the reference species from JetSurf2."""
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        assert nasa_format == NASAFormat.NASA7
        assert len(species_data) == len(REFERENCE_SPECIES)

        loaded_names = {sp.name for sp in species_data}
        assert loaded_names == species_filter

    def test_species_have_thermo_data(self) -> None:
        """Verify all species have NASA coefficients."""
        species_filter = set(REFERENCE_SPECIES)
        species_data, _ = load_cantera_yaml(MECHANISM_FILE, species_filter)

        for sp in species_data:
            assert sp.nasa is not None
            assert len(sp.nasa.T_ranges) >= 3  # T_low, T_mid, T_high
            assert len(sp.nasa.coeffs) >= 2  # low and high ranges
            assert len(sp.nasa.coeffs[0]) == 7  # NASA7 has 7 coefficients

    def test_species_have_transport_data(self) -> None:
        """Verify all species have transport properties."""
        species_filter = set(REFERENCE_SPECIES)
        species_data, _ = load_cantera_yaml(MECHANISM_FILE, species_filter)

        for sp in species_data:
            assert sp.transport is not None, f"{sp.name} missing transport"
            assert sp.transport.diameter > 0
            assert sp.transport.well_depth > 0

    def test_molar_mass_calculation(self) -> None:
        """Verify molar masses are calculated correctly."""
        species_filter = {"CH4", "H2O", "CO2"}
        species_data, _ = load_cantera_yaml(MECHANISM_FILE, species_filter)

        expected = {
            "CH4": 16.043,  # C + 4*H
            "H2O": 18.015,  # 2*H + O (using 15.999 for O)
            "CO2": 44.009,  # C + 2*O
        }

        for sp in species_data:
            assert sp.name in expected
            assert abs(sp.molar_mass - expected[sp.name]) < 0.01, (
                f"{sp.name}: expected {expected[sp.name]}, got {sp.molar_mass}"
            )


class TestGenerateHeader:
    """Test C++ header generation."""

    def test_generates_valid_header(self) -> None:
        """Generate header and verify basic structure."""
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".h", delete=False) as f:
            generate_cpp_header(species_data, nasa_format, f)
            output_path = Path(f.name)

        try:
            content = output_path.read_text()

            # Check header guards
            assert "#ifndef THERMO_TRANSPORT_DATA_H" in content
            assert "#define THERMO_TRANSPORT_DATA_H" in content
            assert "#endif" in content

            # Check format flag
            assert "constexpr bool USE_NASA9 = false;" in content

            # Check all species are present
            for sp in REFERENCE_SPECIES:
                assert f'"{sp}"' in content, f"Species {sp} not in output"

            # Check structs are defined (NASA7_Coeffs with alias, or NASA9_Coeffs)
            assert "struct NASA7_Coeffs" in content or "struct NASA9_Coeffs" in content
            assert "using NASA_Coeffs" in content
            assert "struct Transport_Props" in content
            assert "struct Molecular_Structure" in content
        finally:
            output_path.unlink()

    def test_species_ordering(self) -> None:
        """Verify species are sorted correctly (air species first)."""
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".h", delete=False) as f:
            generate_cpp_header(species_data, nasa_format, f)
            output_path = Path(f.name)

        try:
            content = output_path.read_text()

            # Extract species_names vector
            match = re.search(r"species_names = \{([^}]+)\}", content)
            assert match, "Could not find species_names"

            names_str = match.group(1)
            names = [n.strip().strip('"') for n in names_str.split(",")]

            # Air species should be first, in order
            air_species = ["N2", "O2", "AR", "CO2", "H2O"]
            for i, sp in enumerate(air_species):
                if sp in names:
                    assert names.index(sp) == i, f"{sp} should be at index {i}"
        finally:
            output_path.unlink()


class TestReferenceComparison:
    """Compare generated output with reference header."""

    def test_species_names_match_reference(self) -> None:
        """Verify species names match the reference header."""
        if not REFERENCE_HEADER.exists():
            pytest.skip("Reference header not found")

        ref_content = REFERENCE_HEADER.read_text()

        # Extract species from reference
        match = re.search(r"species_names = \{([^}]+)\}", ref_content)
        assert match
        ref_names = [n.strip().strip('"') for n in match.group(1).split(",")]

        # Generate new header
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".h", delete=False) as f:
            generate_cpp_header(species_data, nasa_format, f)
            output_path = Path(f.name)

        try:
            new_content = output_path.read_text()
            match = re.search(r"species_names = \{([^}]+)\}", new_content)
            assert match
            new_names = [n.strip().strip('"') for n in match.group(1).split(",")]

            assert new_names == ref_names, (
                f"Species order mismatch:\nRef: {ref_names}\nNew: {new_names}"
            )
        finally:
            output_path.unlink()

    def test_molar_masses_match_reference(self) -> None:
        """Verify molar masses match the reference header."""
        if not REFERENCE_HEADER.exists():
            pytest.skip("Reference header not found")

        ref_content = REFERENCE_HEADER.read_text()

        # Extract molar masses from reference
        match = re.search(r"molar_masses = \{([^}]+)\}", ref_content)
        assert match
        ref_masses = [float(m.strip()) for m in match.group(1).split(",")]

        # Generate new header
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".h", delete=False) as f:
            generate_cpp_header(species_data, nasa_format, f)
            output_path = Path(f.name)

        try:
            new_content = output_path.read_text()
            match = re.search(r"molar_masses = \{([^}]+)\}", new_content)
            assert match
            new_masses = [float(m.strip()) for m in match.group(1).split(",")]

            assert len(new_masses) == len(ref_masses)
            for i, (ref, new) in enumerate(zip(ref_masses, new_masses, strict=True)):
                assert abs(ref - new) < 0.01, (
                    f"Molar mass mismatch at index {i}: ref={ref}, new={new}"
                )
        finally:
            output_path.unlink()


class TestTwoFileWorkflow:
    """Test loading thermo and transport from separate sources.

    For now, we simulate this by loading the same YAML file twice,
    which exercises the code path for merging data sources.
    """

    def test_placeholder_for_separate_sources(self) -> None:
        """Placeholder test for future two-file workflow.

        When NASA9 parser is implemented, this will test:
        - Loading thermo from NASA9 database
        - Loading transport from separate file
        - Merging the two sources
        """
        # For now, just verify we can load from single source
        species_filter = set(REFERENCE_SPECIES)
        species_data, nasa_format = load_cantera_yaml(MECHANISM_FILE, species_filter)

        assert len(species_data) == len(REFERENCE_SPECIES)
        assert nasa_format == NASAFormat.NASA7


REAL_COMMON_NAMES_H = Path(__file__).parent.parent / "include" / "common_names.h"


class TestParseCommonNamesHeader:
    """Tests for _parse_common_names_header()."""

    def test_parses_real_header(self) -> None:
        """All 14 active species must be present in the real common_names.h."""
        known = _parse_common_names_header(REAL_COMMON_NAMES_H)
        for formula in REFERENCE_SPECIES:
            assert formula in known, f"{formula} missing from common_names.h"

    def test_returns_empty_for_missing_file(self) -> None:
        known = _parse_common_names_header(Path("/nonexistent/common_names.h"))
        assert known == set()

    def test_parses_synthetic_header(self, tmp_path: Path) -> None:
        header = tmp_path / "common_names.h"
        header.write_text(
            "inline const std::unordered_map<std::string, std::string> formula_to_name{\n"
            '    {"CH4", "Methane"},\n'
            '    {"CO2", "Carbon dioxide"},\n'
            "};\n"
        )
        known = _parse_common_names_header(header)
        assert known == {"CH4", "CO2"}

    def test_keys_are_uppercased(self, tmp_path: Path) -> None:
        header = tmp_path / "common_names.h"
        header.write_text(
            "inline const std::unordered_map<std::string, std::string> formula_to_name{\n"
            '    {"ch4", "Methane"},\n'
            "};\n"
        )
        known = _parse_common_names_header(header)
        assert "CH4" in known
        assert "ch4" not in known


class TestCheckCommonNames:
    """Tests for check_common_names()."""

    def _make_species(self, *names: str) -> list[SpeciesData]:
        """Create minimal SpeciesData stubs with just a name."""
        from generate_thermo_data import NASACoeffs, NASAFormat

        return [
            SpeciesData(
                name=n,
                molar_mass=0.0,
                nasa=NASACoeffs(format=NASAFormat.NASA9, T_ranges=[], coeffs=[]),
            )
            for n in names
        ]

    def test_no_missing_for_known_species(self, capsys: pytest.CaptureFixture) -> None:
        species = self._make_species(*REFERENCE_SPECIES)
        missing = check_common_names(species, REAL_COMMON_NAMES_H)
        assert missing == []
        captured = capsys.readouterr()
        assert captured.out == ""

    def test_warns_for_unknown_species(self, capsys: pytest.CaptureFixture) -> None:
        species = self._make_species("N2", "C2H4")  # C2H4 not in common_names.h
        missing = check_common_names(species, REAL_COMMON_NAMES_H)
        assert missing == ["C2H4"]
        captured = capsys.readouterr()
        assert "Warning" in captured.out
        assert "C2H4" in captured.out

    def test_error_tag_when_strict(self, capsys: pytest.CaptureFixture) -> None:
        species = self._make_species("C2H4")
        missing = check_common_names(species, REAL_COMMON_NAMES_H, error_on_missing=True)
        assert missing == ["C2H4"]
        captured = capsys.readouterr()
        assert "ERROR" in captured.out

    def test_missing_header_treats_all_as_missing(self, capsys: pytest.CaptureFixture) -> None:
        species = self._make_species("N2", "O2")
        missing = check_common_names(species, Path("/nonexistent/common_names.h"))
        assert set(missing) == {"N2", "O2"}


ACTIVE_THERMO_H = Path(__file__).parent.parent / "include" / "thermo_transport_data.h"


class TestCommonNamesSymmetry:
    """Invariant tests directly on include/common_names.h.

    These act as a regression guard: if someone adds a species to
    thermo_transport_data.h or edits common_names.h inconsistently,
    one of these tests will catch it.
    """

    def test_formula_to_name_nonempty(self) -> None:
        f2n = _parse_formula_to_name(REAL_COMMON_NAMES_H)
        assert len(f2n) > 0, "formula_to_name map is empty"

    def test_name_to_formula_nonempty(self) -> None:
        n2f = _parse_name_to_formula(REAL_COMMON_NAMES_H)
        assert len(n2f) > 0, "name_to_formula map is empty"

    def test_maps_same_size(self) -> None:
        """Both maps must have the same number of entries."""
        f2n = _parse_formula_to_name(REAL_COMMON_NAMES_H)
        n2f = _parse_name_to_formula(REAL_COMMON_NAMES_H)
        assert len(f2n) == len(n2f), (
            f"formula_to_name has {len(f2n)} entries but "
            f"name_to_formula has {len(n2f)} — maps are out of sync"
        )

    def test_formula_to_name_is_inverse_of_name_to_formula(self) -> None:
        """For every (formula, name) in formula_to_name, name_to_formula[name] == formula."""
        f2n = _parse_formula_to_name(REAL_COMMON_NAMES_H)
        n2f = _parse_name_to_formula(REAL_COMMON_NAMES_H)
        for formula, name in f2n.items():
            assert name in n2f, f'"{name}" is in formula_to_name but missing from name_to_formula'
            assert n2f[name] == formula, (
                f'name_to_formula["{name}"] = "{n2f[name]}" '
                f'but formula_to_name["{formula}"] = "{name}" — maps disagree'
            )

    def test_name_to_formula_is_inverse_of_formula_to_name(self) -> None:
        """For every (name, formula) in name_to_formula, formula_to_name[formula] == name."""
        f2n = _parse_formula_to_name(REAL_COMMON_NAMES_H)
        n2f = _parse_name_to_formula(REAL_COMMON_NAMES_H)
        for name, formula in n2f.items():
            assert formula in f2n, (
                f'"{formula}" is in name_to_formula but missing from formula_to_name'
            )
            assert f2n[formula] == name, (
                f'formula_to_name["{formula}"] = "{f2n[formula]}" '
                f'but name_to_formula["{name}"] = "{formula}" — maps disagree'
            )

    def test_all_active_species_have_common_name(self) -> None:
        """Every species in thermo_transport_data.h must have a common name."""
        if not ACTIVE_THERMO_H.exists():
            pytest.skip("thermo_transport_data.h not present")
        f2n = _parse_formula_to_name(REAL_COMMON_NAMES_H)
        text = ACTIVE_THERMO_H.read_text()
        import re as _re

        m = _re.search(r"species_names\s*=\s*\{([^;]+)\}", text)
        assert m, "Could not find species_names in thermo_transport_data.h"
        active = _re.findall(r'"([^"]+)"', m.group(1))
        missing = [s for s in active if s not in f2n]
        assert missing == [], (
            f"{len(missing)} active species have no common name: {missing}\n"
            "Add them to include/common_names.h (both maps)."
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
